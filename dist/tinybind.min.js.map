{"version":3,"file":"tinybind.min.js","sources":["../src/constants.js","../src/parsers.js","../src/observer.js","../src/tinybind.js","../src/binding.js","../src/component-binding.js","../src/view.js","../src/adapter.js","../src/binders.js","../src/export.js"],"sourcesContent":["export const OPTIONS = [\n  'prefix',\n  'templateDelimiters',\n  'rootInterface',\n  'preloadData',\n  'handler'\n];\n\nexport const EXTENSIONS = [\n  'binders',\n  'formatters',\n  'components',\n  'adapters'\n];","/**\n * Used also in parsers.parseType\n * TODO outsource\n */\nconst PRIMITIVE = 0;\nconst KEYPATH = 1;\n\nconst QUOTED_STR = /^'.*'$|^\".*\"$/; // regex to test if string is wrapped in \" or '\n\n// Used in parsers.parseTemplate\nconst TEXT = 0;\nconst BINDING = 1;\n\n// Test if string is a json string\nexport function isJson(str) {\n  try {\n    const val = JSON.parse(str);\n    return (val instanceof Array || val instanceof Object) ? true : false;\n  }\n  catch (error) {\n    return false;\n  }\n}\n\n// Parser and tokenizer for getting the type and value from a string.\nexport function parseType(string) {\n  let type = PRIMITIVE;\n  let value = string;\n  if (QUOTED_STR.test(string)) {\n    value = string.slice(1, -1);\n  } else if (string === 'true') {\n    value = true;\n  } else if (string === 'false') {\n    value = false;\n  } else if (string === 'null') {\n    value = null;\n  } else if (string === 'undefined') {\n    value = undefined;\n  } else if (!isNaN(string)) {\n    value = Number(string);\n  } else if (isJson(string)) {\n    value = JSON.parse(string);\n  } else {\n    type = KEYPATH;\n  }\n  return {type: type, value: value};\n}\n\n// Template parser and tokenizer for mustache-style text content bindings.\n// Parses the template and returns a set of tokens, separating static portions\n// of text from binding declarations.\nexport function parseTemplate(template, delimiters) {\n  var tokens;\n  let length = template.length;\n  let index = 0;\n  let lastIndex = 0;\n  let open = delimiters[0], close = delimiters[1];\n\n  while (lastIndex < length) {\n    index = template.indexOf(open, lastIndex);\n\n    if (index < 0) {\n      if (tokens) {\n        tokens.push({\n          type: TEXT,\n          value: template.slice(lastIndex)\n        });\n      }\n\n      break;\n    } else {\n      tokens = tokens || [];\n      if (index > 0 && lastIndex < index) {\n        tokens.push({\n          type: TEXT,\n          value: template.slice(lastIndex, index)\n        });\n      }\n\n      lastIndex = index + open.length;\n      index = template.indexOf(close, lastIndex);\n\n      if (index < 0) {\n        let substring = template.slice(lastIndex - close.length);\n        let lastToken = tokens[tokens.length - 1];\n\n        if (lastToken && lastToken.type === TEXT) {\n          lastToken.value += substring;\n        } else {\n          tokens.push({\n            type: TEXT,\n            value: substring\n          });\n        }\n\n        break;\n      }\n\n      let value = template.slice(lastIndex, index).trim();\n\n      tokens.push({\n        type: BINDING,\n        value: value\n      });\n\n      lastIndex = index + close.length;\n    }\n  }\n\n  return tokens;\n}\n","\n// Check if a value is an object than can be observed.\nfunction isObject(obj) {\n  return typeof obj === 'object' && obj !== null;\n}\n\n// Error thrower.\nfunction error(message) {\n  throw new Error('[Observer] ' + message);\n}\n\nvar adapters;\nvar interfaces;\nvar rootInterface;\n\n// Constructs a new keypath observer and kicks things off.\nfunction Observer(obj, keypath, callback) {\n  this.keypath = keypath;\n  this.callback = callback;\n  this.objectPath = [];\n  this.parse();\n  this.obj = this.getRootObject(obj);\n\n  if (isObject(this.target = this.realize())) {\n    this.set(true, this.key, this.target, this.callback);\n  }\n}\n\nObserver.updateOptions = function(options) {\n  adapters = options.adapters;\n  interfaces = Object.keys(adapters);\n  rootInterface = options.rootInterface;\n};\n\n// Tokenizes the provided keypath string into interface + path tokens for the\n// observer to work with.\nObserver.tokenize = function(keypath, root) {\n  var tokens = [];\n  var current = {i: root, path: ''};\n  var index, chr;\n\n  for (index = 0; index < keypath.length; index++) {\n    chr = keypath.charAt(index);\n\n    if (!!~interfaces.indexOf(chr)) {\n      tokens.push(current);\n      current = {i: chr, path: ''};\n    } else {\n      current.path += chr;\n    }\n  }\n\n  tokens.push(current);\n  return tokens;\n};\n\n// Parses the keypath using the interfaces defined on the view. Sets variables\n// for the tokenized keypath as well as the end key.\nObserver.prototype.parse = function() {\n  var path, root;\n\n  if (!interfaces.length) {\n    error('Must define at least one adapter interface.');\n  }\n\n  if (!!~interfaces.indexOf(this.keypath[0])) {\n    root = this.keypath[0];\n    path = this.keypath.substr(1);\n  } else {\n    root = rootInterface;\n    path = this.keypath;\n  }\n\n  this.tokens = Observer.tokenize(path, root);\n  this.key = this.tokens.pop();\n};\n\n// Realizes the full keypath, attaching observers for every key and correcting\n// old observers to any changed objects in the keypath.\nObserver.prototype.realize = function() {\n  var current = this.obj;\n  var unreached = -1;\n  var prev;\n  var token;\n\n  for (let index = 0; index < this.tokens.length; index++) {\n    token = this.tokens[index];\n    if (isObject(current)) {\n      if (typeof this.objectPath[index] !== 'undefined') {\n        if (current !== (prev = this.objectPath[index])) {\n          this.set(false, token, prev, this);\n          this.set(true, token, current, this);\n          this.objectPath[index] = current;\n        }\n      } else {\n        this.set(true, token, current, this);\n        this.objectPath[index] = current;\n      }\n\n      current = this.get(token, current);\n    } else {\n      if (unreached === -1) {\n        unreached = index;\n      }\n\n      prev = this.objectPath[index];\n      if (prev) {\n        this.set(false, token, prev, this);\n      }\n    }\n  }\n\n  if (unreached !== -1) {\n    this.objectPath.splice(unreached);\n  }\n\n  return current;\n};\n\n// Updates the keypath. This is called when any intermediary key is changed.\nObserver.prototype.sync = function() {\n  var next, oldValue, newValue;\n\n  if ((next = this.realize()) !== this.target) {\n    if (isObject(this.target)) {\n      this.set(false, this.key, this.target, this.callback);\n    }\n\n    if (isObject(next)) {\n      this.set(true, this.key, next, this.callback);\n    }\n\n    oldValue = this.value();\n    this.target = next;\n    newValue = this.value();\n    if (newValue !== oldValue || newValue instanceof Function) this.callback.sync();\n  } else if (next instanceof Array) {\n    this.callback.sync();\n  }\n};\n\n// Reads the current end value of the observed keypath. Returns undefined if\n// the full keypath is unreachable.\nObserver.prototype.value = function() {\n  if (isObject(this.target)) {\n    return this.get(this.key, this.target);\n  }\n};\n\n// Sets the current end value of the observed keypath. Calling setValue when\n// the full keypath is unreachable is a no-op.\nObserver.prototype.setValue = function(value) {\n  if (isObject(this.target)) {\n    adapters[this.key.i].set(this.target, this.key.path, value);\n  }\n};\n\n// Gets the provided key on an object.\nObserver.prototype.get = function(key, obj) {\n  return adapters[key.i].get(obj, key.path);\n};\n\n// Observes or unobserves a callback on the object using the provided key.\nObserver.prototype.set = function(active, key, obj, callback) {\n  var action = active ? 'observe' : 'unobserve';\n  adapters[key.i][action](obj, key.path, callback);\n};\n\n\n// Unobserves the entire keypath.\nObserver.prototype.unobserve = function() {\n  var obj;\n  var token;\n\n  for (let index = 0; index < this.tokens.length; index++) {\n    token = this.tokens[index];\n    obj = this.objectPath[index];\n    if (obj) {\n      this.set(false, token, obj, this);\n    }\n  }\n\n  if (isObject(this.target)) {\n    this.set(false, this.key, this.target, this.callback);\n  }\n};\n// traverse the scope chain to find the scope which has the root property\n// if the property is not found in chain, returns the root scope\nObserver.prototype.getRootObject = function (obj) {\n  var rootProp, current;\n  if (!obj.$parent) {\n    return obj;\n  }\n\n  if (this.tokens.length) {\n    rootProp = this.tokens[0].path;\n  } else {\n    rootProp = this.key.path;\n  }\n\n  current = obj;\n  while (current.$parent && (current[rootProp] === undefined)) {\n    current = current.$parent;\n  }\n\n  return current;\n};\n\nexport default Observer;\n","import {EXTENSIONS} from './constants';\nimport {parseTemplate, parseType} from './parsers';\n\nconst tinybind = {\n  // Global binders.\n  binders: {},\n\n  // Global components.\n  components: {},\n\n  // Global formatters.\n  formatters: {},\n\n  // Global sightglass adapters.\n  adapters: {},\n\n  // Default attribute prefix.\n  _prefix: 'rv',\n\n  _fullPrefix: 'rv-',\n\n  get prefix () {\n    return this._prefix;\n  },\n\n  set prefix (value) {\n    this._prefix = value;\n    this._fullPrefix = value + '-';\n  },\n\n  parseTemplate: parseTemplate,\n\n  parseType: parseType,\n\n  // Default template delimiters.\n  templateDelimiters: ['{', '}'],\n\n  // Default sightglass root interface.\n  rootInterface: '.',\n\n  // Preload data by default.\n  preloadData: true,\n\n  // Default event handler.\n  handler: function(context, ev, binding) {\n    this.call(context, ev, binding.view.models);\n  },\n\n  // Sets the attribute on the element. If no binder above is matched it will fall\n  // back to using this binder.\n  fallbackBinder: function(el, value) {\n    if (value != null) {\n      el.setAttribute(this.type, value);\n    } else {\n      el.removeAttribute(this.type);\n    }  \n  },\n\n  // Merges an object literal into the corresponding global options.\n  configure: function(options) {\n    if (!options) {\n      return;\n    }\n    Object.keys(options).forEach(option => {\n      let value = options[option];\n\n      if (EXTENSIONS.indexOf(option) > -1) {\n        Object.keys(value).forEach(key => {\n          this[option][key] = value[key];\n        });\n      } else {\n        this[option] = value;\n      }\n    });\n  }\n};\n\nexport default tinybind;\n","import {parseType} from './parsers';\nimport Observer from './observer';\n\nfunction getInputValue(el) {\n  let results = [];\n  if (el.type === 'checkbox') {\n    return el.checked;\n  } else if (el.type === 'select-multiple') {\n\n    el.options.forEach(option => {\n      if (option.selected) {\n        results.push(option.value);\n      }\n    });\n\n    return results;\n  } else {\n    return el.value;\n  }\n}\n\nconst FORMATTER_ARGS =  /[^\\s']+|'([^']|'[^\\s])*'|\"([^\"]|\"[^\\s])*\"/g;\nconst FORMATTER_SPLIT = /\\s+/;\n\n/**\n * Used also in parsers.parseType\n * TODO outsource\n */\nconst PRIMITIVE = 0;\nconst KEYPATH = 1;\n\n// A single binding between a model attribute and a DOM element.\nexport class Binding {\n  /**\n   * All information about the binding is passed into the constructor; the\n   * containing view, the DOM node, the type of binding, the model object and the\n   * keypath at which to listen for changes.\n   * @param {*} view \n   * @param {*} el \n   * @param {*} type \n   * @param {*} keypath \n   * @param {*} binder \n   * @param {*} args The start binders, on `class-*` args[0] wil be the classname \n   * @param {*} formatters \n   */\n  constructor(view, el, type, keypath, binder, args, formatters) {\n    this.view = view;\n    this.el = el;\n    this.type = type;\n    this.keypath = keypath;\n    this.binder = binder;\n    this.args = args;\n    this.formatters = formatters;\n    this.formatterObservers = {};\n    this.model = undefined;\n  }\n\n  // Observes the object keypath\n  observe(obj, keypath) {\n    return new Observer(obj, keypath, this);\n  }\n\n  parseTarget() {\n    if (this.keypath) {\n      let token = parseType(this.keypath);\n      if (token.type === PRIMITIVE) {\n        this.value = token.value;\n      } else if(token.type === KEYPATH){\n        this.observer = this.observe(this.view.models, this.keypath);\n        this.model = this.observer.target;\n      } else {\n        throw new Error('Unknown type in token', token);\n      }\n    } else {\n      this.value = undefined;\n    }\n  }\n  \n  /**\n   * Get the iteration alias, used in the interation binders like `each-*`\n   * @param {*} modelName \n   * @see https://github.com/mikeric/rivets/blob/master/dist/rivets.js#L26\n   * @see https://github.com/mikeric/rivets/blob/master/dist/rivets.js#L1175\n   */\n  getIterationAlias(modelName) {\n    return '%' + modelName + '%';\n  }\n\n  parseFormatterArguments(args, formatterIndex) {\n    return args\n      .map(parseType)\n      .map(({type, value}, ai) => {\n        if (type === PRIMITIVE) {\n          return value;\n        } else if (type === KEYPATH) {\n          if (!this.formatterObservers[formatterIndex]) {\n            this.formatterObservers[formatterIndex] = {};\n          }\n\n          let observer = this.formatterObservers[formatterIndex][ai];\n\n          if (!observer) {\n            observer = this.observe(this.view.models, value);\n            this.formatterObservers[formatterIndex][ai] = observer;\n          }\n\n          return observer.value();\n        } else {\n          throw new Error('Unknown type', type, value);\n        }\n      });\n  }\n\n  // Applies all the current formatters to the supplied value and returns the\n  // formatted value.\n  formattedValue(value) {\n    return this.formatters.reduce((result, declaration, index) => {\n      let args = declaration.match(FORMATTER_ARGS);\n      let id = args.shift();\n      let formatter = this.view.options.formatters[id];\n\n      const processedArgs = this.parseFormatterArguments(args, index);\n\n      if (formatter && (formatter.read instanceof Function)) {\n        result = formatter.read(result, ...processedArgs);\n      } else if (formatter instanceof Function) {\n        result = formatter(result, ...processedArgs);\n      }\n      return result;\n    }, value);\n  }\n\n  // Returns an event handler for the binding around the supplied function.\n  eventHandler(fn) {\n    let binding = this;\n    let handler = binding.view.options.handler;\n\n    return function(ev) {\n      handler.call(fn, this, ev, binding);\n    };\n  }\n\n  // Sets the value for the binding. This Basically just runs the binding routine\n  // with the supplied value formatted.\n  set(value) {\n    if ((value instanceof Function) && !this.binder.function) {\n      value = this.formattedValue(value.call(this.model));\n    } else {\n      value = this.formattedValue(value);\n    }\n\n    let routineFn = this.binder.routine || this.binder;\n\n    if (routineFn instanceof Function) {\n      routineFn.call(this, this.el, value);\n    }\n  }\n\n  // Syncs up the view binding with the model.\n  sync() {\n    if (this.observer) {\n      this.model = this.observer.target;\n      this.set(this.observer.value());\n    } else {\n      this.set(this.value);\n    }\n  }\n\n  // Publishes the value currently set on the input element back to the model.\n  publish() {\n    if (this.observer) {\n      var value = this.formatters.reduceRight((result, declaration, index) => {\n        const args = declaration.split(FORMATTER_SPLIT);\n        const id = args.shift();\n        const formatter = this.view.options.formatters[id];\n        const processedArgs = this.parseFormatterArguments(args, index);\n\n        if (formatter && formatter.publish) {\n          result = formatter.publish(result, ...processedArgs);\n        }\n        return result;\n      }, this.getValue(this.el));\n\n      this.observer.setValue(value);\n    }\n  }\n\n  // Subscribes to the model for changes at the specified keypath. Bi-directional\n  // routines will also listen for changes on the element to propagate them back\n  // to the model.\n  bind() {\n    this.parseTarget();\n\n    if (this.binder.hasOwnProperty('bind')) {\n      this.binder.bind.call(this, this.el);\n    }\n\n    if (this.view.options.preloadData) {\n      this.sync();\n    }\n  }\n\n  // Unsubscribes from the model and the element.\n  unbind() {\n    if (this.binder.unbind) {\n      this.binder.unbind.call(this, this.el);\n    }\n\n    if (this.observer) {\n      this.observer.unobserve();\n    }\n\n    Object.keys(this.formatterObservers).forEach(fi => {\n      let args = this.formatterObservers[fi];\n\n      Object.keys(args).forEach(ai => {\n        args[ai].unobserve();\n      });\n    });\n\n    this.formatterObservers = {};\n  }\n\n  // Updates the binding's model from what is currently set on the view. Unbinds\n  // the old model first and then re-binds with the new model.\n  update(models = {}) {\n    if (this.observer) {\n      this.model = this.observer.target;\n    }\n\n    if (this.binder.update) {\n      this.binder.update.call(this, models);\n    }\n  }\n\n  // Returns elements value\n  getValue(el) {\n    if (this.binder && this.binder.getValue) {\n      return this.binder.getValue.call(this, el);\n    } else {\n      return getInputValue(el);\n    }\n  }\n}\n","import tinybind from './tinybind';\nimport {parseType} from './parsers';\nimport {EXTENSIONS, OPTIONS} from './constants';\nimport {Binding} from './binding';\n\n/**\n * Used also in parsers.parseType\n * TODO outsource\n */\nconst PRIMITIVE = 0;\nconst KEYPATH = 1;\n\n// component view encapsulated as a binding within it's parent view.\nexport class ComponentBinding extends Binding {\n  // Initializes a component binding for the specified view. The raw component\n  // element is passed in along with the component type. Attributes and scope\n  // inflections are determined based on the components defined attributes.\n  constructor(view, el, type) {\n    super(view, el, type, null, null, null, null);\n    this.view = view;\n    this.el = el;\n    this.type = type;\n    this.component = view.options.components[this.type];\n    this.static = {};\n    this.observers = {};\n    this.upstreamObservers = {};\n    \n    let bindingPrefix = tinybind._fullPrefix;\n    \n    // parse component attributes\n    for (let i = 0, len = el.attributes.length; i < len; i++) {\n      let attribute = el.attributes[i];\n\n      // if attribute starts not with binding prefix. E.g. rv-\n      if (attribute.name.indexOf(bindingPrefix) !== 0) {\n        let propertyName = this.camelCase(attribute.name);\n        let token = parseType(attribute.value);\n        let stat = this.component.static;\n    \n        if (stat && stat.indexOf(propertyName) > -1) {\n          this.static[propertyName] = attribute.value;\n        } else if(token.type === PRIMITIVE) {\n          this.static[propertyName] = token.value;\n        } else if(token.type === KEYPATH) {\n          this.observers[propertyName] = attribute.value;\n        } else {\n          throw new Error('can\\'t parse component attribute', attribute, token);\n        }\n      }\n    }\n  }\n    \n    \n  // Intercepts `tinybind.Binding::sync` since component bindings are not bound to\n  // a particular model to update it's value.\n  sync() {}\n    \n  // Intercepts `tinybind.Binding::update` since component bindings are not bound\n  // to a particular model to update it's value.\n  update() {}\n    \n  // Intercepts `tinybind.Binding::publish` since component bindings are not bound\n  // to a particular model to update it's value.\n  publish() {}\n    \n  // Returns an object map using the component's scope inflections.\n  locals() {\n    let result = {};\n    \n    Object.keys(this.static).forEach(key => {\n      result[key] = this.static[key];\n    });\n    \n    Object.keys(this.observers).forEach(key => {\n      result[key] = this.observers[key].value();\n    });\n    \n    return result;\n  }\n    \n  // Returns a camel-cased version of the string. Used when translating an\n  // element's attribute name into a property name for the component's scope.\n  camelCase(string) {\n    return string.replace(/-([a-z])/g, grouped => {\n      return grouped[1].toUpperCase();\n    });\n  }\n    \n  // Intercepts `tinybind.Binding::bind` to build `this.componentView` with a localized\n  // map of models from the root view. Bind `this.componentView` on subsequent calls.\n  bind() {\n    var options = {};\n    if (!this.bound) {\n      Object.keys(this.observers).forEach(key => {\n        let keypath = this.observers[key];\n    \n        this.observers[key] = this.observe(this.view.models, keypath, (key => {\n          return () => {\n            this.componentView.models[key] = this.observers[key].value();\n          };\n        }).call(this, key));\n      });\n    \n      this.bound = true;\n    }\n    \n    if (this.componentView) {\n      this.componentView.bind();\n    } else {\n      this.el.innerHTML = this.component.template.call(this);\n      let scope = this.component.initialize.call(this, this.el, this.locals());\n      this.el._bound = true;\n    \n    \n      EXTENSIONS.forEach(extensionType => {\n        options[extensionType] = {};\n    \n        if (this.component[extensionType]) {\n          Object.keys(this.component[extensionType]).forEach(key => {\n            options[extensionType][key] = this.component[extensionType][key];\n          });\n        }\n    \n        Object.keys(this.view.options[extensionType]).forEach(key => {\n          if (options[extensionType][key]) {\n            options[extensionType][key] = this.view[extensionType][key];\n          }\n        });\n      });\n    \n      OPTIONS.forEach(option => {\n        if (this.component[option] != null) {\n          options[option] = this.component[option];\n        } else {\n          options[option] = this.view[option];\n        }\n      });\n    \n      //there's a cyclic dependency that makes imported View a dummy object. Use tinybind.bind\n      //this.componentView = new View(this.el, scope, options)\n      //this.componentView.bind()\n      this.componentView = tinybind.bind(Array.prototype.slice.call(this.el.childNodes), scope, options);\n    \n      Object.keys(this.observers).forEach(key => {\n        let observer = this.observers[key];\n        let models = this.componentView.models;\n    \n        let upstream = this.observe(models, key, ((key, observer) => {\n          return () => {\n            observer.setValue(this.componentView.models[key]);\n          };\n        }).call(this, key, observer));\n    \n        this.upstreamObservers[key] = upstream;\n      });\n    }\n  }\n    \n  // Intercept `tinybind.Binding::unbind` to be called on `this.componentView`.\n  unbind() {\n    Object.keys(this.upstreamObservers).forEach(key => {\n      this.upstreamObservers[key].unobserve();\n    });\n    \n    Object.keys(this.observers).forEach(key => {\n      this.observers[key].unobserve();\n    });\n    \n    if (this.componentView) {\n      this.componentView.unbind.call(this);\n    }\n  }\n}","import tinybind from './tinybind';\nimport { Binding } from './binding';\nimport { ComponentBinding } from './component-binding';\nimport { parseTemplate } from './parsers';\n\nconst textBinder = {\n  routine: (node, value) => {\n    node.data = (value != null) ? value : '';\n  }\n};\n\nconst DECLARATION_SPLIT = /((?:'[^']*')*(?:(?:[^\\|']*(?:'[^']*')+[^\\|']*)+|[^\\|]+))|^$/g;\n\nconst parseNode = (view, node) => {\n  let block = false;\n\n  if (node.nodeType === 3) {\n    let tokens = parseTemplate(node.data, tinybind.templateDelimiters);\n\n    if (tokens) {\n      for (let i = 0; i < tokens.length; i++) {\n        let token = tokens[i];\n        let text = document.createTextNode(token.value);\n        node.parentNode.insertBefore(text, node);\n\n        if (token.type === 1) {\n          view.buildBinding(text, null, token.value, textBinder, null);\n        }\n      }\n\n      node.parentNode.removeChild(node);\n    }\n    block = true;\n  } else if (node.nodeType === 1) {\n    block = view.traverse(node);\n  }\n\n  if (!block) {\n    for (let i = 0; i < node.childNodes.length; i++) {\n      parseNode(view, node.childNodes[i]);\n    }\n  }\n};\n\nconst bindingComparator = (a, b) => {\n  let aPriority = a.binder ? (a.binder.priority || 0) : 0;\n  let bPriority = b.binder ? (b.binder.priority || 0) : 0;\n  return bPriority - aPriority;\n};\n\nconst trimStr = (str) => {\n  return str.trim();\n};\n\n// A collection of bindings built from a set of parent nodes.\nexport default class View {\n  // The DOM elements and the model objects for binding are passed into the\n  // constructor along with any local options that should be used throughout the\n  // context of the view and it's bindings.\n  constructor(els, models, options) {\n    if (els.jquery || els instanceof Array) {\n      this.els = els;\n    } else {\n      this.els = [els];\n    }\n\n    this.models = models;\n    this.options = options;\n\n    this.build();\n  }\n\n\n  buildBinding(node, type, declaration, binder, args) {\n    let pipes = declaration.match(DECLARATION_SPLIT).map(trimStr);\n    let keypath = pipes.shift();\n    this.bindings.push(new Binding(this, node, type, keypath, binder, args, pipes));\n  }\n\n  // Parses the DOM tree and builds `Binding` instances for every matched\n  // binding declaration.\n  build() {\n    this.bindings = [];\n\n    let elements = this.els, i, len;\n    for (i = 0, len = elements.length; i < len; i++) {\n      parseNode(this, elements[i]);\n    }\n\n    this.bindings.sort(bindingComparator);\n  }\n\n  traverse(node) {\n    let bindingPrefix = tinybind._fullPrefix;\n    let block = node.nodeName === 'SCRIPT' || node.nodeName === 'STYLE';\n    let attributes = node.attributes;\n    let bindInfos = [];\n    let starBinders = this.options.starBinders;\n    var type, binder, identifier, args;\n\n\n    for (let i = 0, len = attributes.length; i < len; i++) {\n      let attribute = attributes[i];\n      // if attribute starts with the binding prefix. E.g. rv\n      if (attribute.name.indexOf(bindingPrefix) === 0) {\n        type = attribute.name.slice(bindingPrefix.length);\n        binder = this.options.binders[type];\n        args = [];\n\n        if (!binder) {\n          for (let k = 0; k < starBinders.length; k++) {\n            identifier = starBinders[k];\n            if (type.slice(0, identifier.length - 1) === identifier.slice(0, -1)) {\n              binder = this.options.binders[identifier];\n              args.push(type.slice(identifier.length - 1));\n              break;\n            }\n          }\n        }\n\n        if (!binder) {\n          binder = tinybind.fallbackBinder;\n        }\n\n        if (binder.block) {\n          this.buildBinding(node, type, attribute.value, binder, args);\n          node.removeAttribute(attribute.name);\n          return true;\n        }\n\n        bindInfos.push({attr: attribute, binder: binder, type: type, args: args});\n      }\n    }\n\n    for (let i = 0; i < bindInfos.length; i++) {\n      let bindInfo = bindInfos[i];\n      this.buildBinding(node, bindInfo.type, bindInfo.attr.value, bindInfo.binder, bindInfo.args);\n      node.removeAttribute(bindInfo.attr.name);\n    }\n\n    // bind components\n    if (!block) {\n      type = node.nodeName.toLowerCase();\n\n      if (this.options.components[type] && !node._bound) {\n        this.bindings.push(new ComponentBinding(this, node, type));\n        block = true;\n      }\n    }\n\n    return block;\n  }\n\n  // Binds all of the current bindings for this view.\n  bind() {\n    this.bindings.forEach(binding => {\n      binding.bind();\n    });\n  }\n\n  // Unbinds all of the current bindings for this view.\n  unbind() {\n    if(Array.isArray(this.bindings)) {\n      this.bindings.forEach(binding => {\n        binding.unbind();\n      });\n    }\n    if(this.componentView) {\n      this.componentView.unbind();\n    }\n  }\n\n  // Syncs up the view with the model by running the routines on all bindings.\n  sync() {\n    this.bindings.forEach(binding => {\n      binding.sync();\n    });\n  }\n\n  // Publishes the input values from the view back to the model (reverse sync).\n  publish() {\n    this.bindings.forEach(binding => {\n      if (binding.binder && binding.binder.publishes) {\n        binding.publish();\n      }\n    });\n  }\n\n  // Updates the view's models along with any affected bindings.\n  update(models = {}) {\n    Object.keys(models).forEach(key => {\n      this.models[key] = models[key];\n    });\n\n    this.bindings.forEach(binding => {\n      if (binding.update) {\n        binding.update(models);\n      }\n    });\n  }\n}\n","// The default `.` adapter that comes with tinybind.js. Allows subscribing to\n// properties on plain objects, implemented in ES5 natives using\n// `Object.defineProperty`.\n\nconst ARRAY_METHODS = [\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'sort',\n  'reverse',\n  'splice'\n];\n\nconst adapter = {\n  counter: 0,\n  weakmap: {},\n\n  weakReference: function(obj) {\n    if (!obj.hasOwnProperty('__rv')) {\n      let id = this.counter++;\n\n      Object.defineProperty(obj, '__rv', {\n        value: id\n      });\n    }\n\n    if (!this.weakmap[obj.__rv]) {\n      this.weakmap[obj.__rv] = {\n        callbacks: {}\n      };\n    }\n\n    return this.weakmap[obj.__rv];\n  },\n\n  cleanupWeakReference: function(ref, id) {\n    if (!Object.keys(ref.callbacks).length) {\n      if (!(ref.pointers && Object.keys(ref.pointers).length)) {\n        delete this.weakmap[id];\n      }\n    }\n  },\n\n  stubFunction: function(obj, fn) {\n    let original = obj[fn];\n    let map = this.weakReference(obj);\n    let weakmap = this.weakmap;\n\n    obj[fn] = (...args) => {\n      let response = original.apply(obj, args);\n\n      Object.keys(map.pointers).forEach(r => {\n        let k = map.pointers[r];\n\n        if (weakmap[r]) {\n          if (weakmap[r].callbacks[k] instanceof Array) {\n            weakmap[r].callbacks[k].forEach(callback => {\n              callback.sync();\n            });\n          }\n        }\n      });\n\n      return response;\n    };\n  },\n\n  observeMutations: function(obj, ref, keypath) {\n    if (obj instanceof Array) {\n      let map = this.weakReference(obj);\n\n      if (!map.pointers) {\n        map.pointers = {};\n\n        ARRAY_METHODS.forEach(fn => {\n          this.stubFunction(obj, fn);\n        });\n      }\n\n      if (!map.pointers[ref]) {\n        map.pointers[ref] = [];\n      }\n\n      if (map.pointers[ref].indexOf(keypath) === -1) {\n        map.pointers[ref].push(keypath);\n      }\n    }\n  },\n\n  unobserveMutations: function(obj, ref, keypath) {\n    if ((obj instanceof Array) && (obj.__rv != null)) {\n      let map = this.weakmap[obj.__rv];\n\n      if (map) {\n        let pointers = map.pointers[ref];\n\n        if (pointers) {\n          let idx = pointers.indexOf(keypath);\n\n          if (idx > -1) {\n            pointers.splice(idx, 1);\n          }\n\n          if (!pointers.length) {\n            delete map.pointers[ref];\n          }\n\n          this.cleanupWeakReference(map, obj.__rv);\n        }\n      }\n    }\n  },\n\n  observe: function(obj, keypath, callback) {\n    var value;\n    let callbacks = this.weakReference(obj).callbacks;\n\n    if (!callbacks[keypath]) {\n      callbacks[keypath] = [];\n      let desc = Object.getOwnPropertyDescriptor(obj, keypath);\n\n      if (!desc || !(desc.get || desc.set || !desc.configurable)) {\n        value = obj[keypath];\n\n        Object.defineProperty(obj, keypath, {\n          enumerable: true,\n\n          get: () => {\n            return value;\n          },\n\n          set: newValue => {\n            if (newValue !== value) {\n              this.unobserveMutations(value, obj.__rv, keypath);\n              value = newValue;\n              let map = this.weakmap[obj.__rv];\n\n              if (map) {\n                let callbacks = map.callbacks[keypath];\n\n                if (callbacks) {\n                  callbacks.forEach(cb => {\n                      cb.sync();\n                  });\n                }\n\n                this.observeMutations(newValue, obj.__rv, keypath);\n              }\n            }\n          }\n        });\n      }\n    }\n\n    if (callbacks[keypath].indexOf(callback) === -1) {\n      callbacks[keypath].push(callback);\n    }\n\n    this.observeMutations(obj[keypath], obj.__rv, keypath);\n  },\n\n  unobserve: function(obj, keypath, callback) {\n    let map = this.weakmap[obj.__rv];\n\n    if (map) {\n      let callbacks = map.callbacks[keypath];\n\n      if (callbacks) {\n        let idx = callbacks.indexOf(callback);\n\n        if (idx > -1) {\n          callbacks.splice(idx, 1);\n\n          if (!callbacks.length) {\n            delete map.callbacks[keypath];\n            this.unobserveMutations(obj[keypath], obj.__rv, keypath);\n          }\n        }\n\n        this.cleanupWeakReference(map, obj.__rv);\n      }\n    }\n  },\n\n  get: function(obj, keypath) {\n    return obj[keypath];\n  },\n\n  set: (obj, keypath, value) => {\n    obj[keypath] = value;\n  }\n};\n\nexport default adapter;\n","import View from './view';\n\nconst getString = (value) => {\n  return value != null ? value.toString() : undefined;\n};\n\nconst times = (n, cb) => {\n  for (let i = 0; i < n; i++) cb();\n};\n\nfunction createView(binding, data, anchorEl) {\n  let template = binding.el.cloneNode(true);\n  let view = new View(template, data, binding.view.options);\n  view.bind();\n  binding.marker.parentNode.insertBefore(template, anchorEl);\n  return view;\n}\n\nconst binders = {\n  // Binds an event handler on the element.\n  'on-*': {\n    function: true,\n    priority: 1000,\n\n    unbind: function(el) {\n      if (this.handler) {\n        el.removeEventListener(this.args[0], this.handler);\n      }\n    },\n\n    routine: function(el, value) {\n      if (this.handler) {\n        el.removeEventListener(this.args[0], this.handler);\n      }\n\n      this.handler = this.eventHandler(value);\n      el.addEventListener(this.args[0], this.handler);\n    }\n  },\n\n  // Appends bound instances of the element in place for each item in the array.\n  'each-*': {\n    block: true,\n\n    priority: 4000,\n\n    bind(el) {\n      if (!this.marker) {\n        this.marker = document.createComment(` tinybind: ${this.type} `);\n        this.iterated = [];\n\n        el.parentNode.insertBefore(this.marker, el);\n        el.parentNode.removeChild(el);\n      } else {\n        this.iterated.forEach(view => {\n          view.bind();\n        });\n      }\n    },\n\n    unbind(el) {\n      if (this.iterated) {\n        this.iterated.forEach(view => {\n          view.unbind();\n        });\n      }\n    },\n\n    routine(el, collection) {\n      let modelName = this.args[0];\n      collection = collection || [];\n\n      // TODO support object keys to iterate over\n      if(!Array.isArray(collection)) {\n        throw new Error('each-' + modelName + ' needs an array to iterate over, but it is', collection);\n      }\n\n      // if index name is seted by `index-property` use this name, otherwise `%[modelName]%`  \n      let indexProp = el.getAttribute('index-property') || this.getIterationAlias(modelName);\n\n      collection.forEach((model, index) => {\n        let data = {$parent: this.view.models};\n        data[indexProp] = index;\n        data[modelName] = model;\n        let view = this.iterated[index];\n\n        if (!view) {\n\n          let previous = this.marker;\n\n          if (this.iterated.length) {\n            previous = this.iterated[this.iterated.length - 1].els[0];\n          }\n\n          view = createView(this, data, previous.nextSibling);\n          this.iterated.push(view);\n        } else {\n          if (view.models[modelName] !== model) {\n            // search for a view that matches the model\n            let matchIndex, nextView;\n            for (let nextIndex = index + 1; nextIndex < this.iterated.length; nextIndex++) {\n              nextView = this.iterated[nextIndex];\n              if (nextView.models[modelName] === model) {\n                matchIndex = nextIndex;\n                break;\n              }\n            }\n            if (matchIndex !== undefined) {\n              // model is in other position\n              // todo: consider avoiding the splice here by setting a flag\n              // profile performance before implementing such change\n              this.iterated.splice(matchIndex, 1);\n              this.marker.parentNode.insertBefore(nextView.els[0], view.els[0]);\n              nextView.models[indexProp] = index;\n            } else {\n              //new model\n              nextView = createView(this, data, view.els[0]);\n            }\n            this.iterated.splice(index, 0, nextView);\n          } else {\n            view.models[indexProp] = index;\n          }\n        }\n      });\n\n      if (this.iterated.length > collection.length) {\n        times(this.iterated.length - collection.length, () => {\n          let view = this.iterated.pop();\n          view.unbind();\n          this.marker.parentNode.removeChild(view.els[0]);\n        });\n      }\n\n      if (el.nodeName === 'OPTION') {\n        this.view.bindings.forEach(binding => {\n          if (binding.el === this.marker.parentNode && binding.type === 'value') {\n            binding.sync();\n          }\n        });\n      }\n    },\n\n    update(models) {\n      let data = {};\n\n      //todo: add test and fix if necessary\n\n      Object.keys(models).forEach(key => {\n        if (key !== this.args[0]) {\n          data[key] = models[key];\n        }\n      });\n\n      this.iterated.forEach(view => {\n        view.update(data);\n      });\n    }\n  },\n\n  // Adds or removes the class from the element when value is true or false.\n  'class-*': function(el, value) {\n    let elClass = ` ${el.className} `;\n\n    if (value !== (elClass.indexOf(` ${this.args[0]} `) > -1)) {\n      if (value) {\n        el.className = `${el.className} ${this.args[0]}`;\n      } else {\n        el.className = elClass.replace(` ${this.args[0]} `, ' ').trim();\n      }\n    }\n  },\n\n  // Sets the element's text value.\n  text: (el, value) => {\n    el.textContent = value != null ? value : '';\n  },\n\n  // Sets the element's HTML content.\n  html: (el, value) => {\n    el.innerHTML = value != null ? value : '';\n  },\n\n  // Shows the element when value is true.\n  show: (el, value) => {\n    el.style.display = value ? '' : 'none';\n  },\n\n  // Hides the element when value is true (negated version of `show` binder).\n  hide: (el, value) => {\n    el.style.display = value ? 'none' : '';\n  },\n\n  // Enables the element when value is true.\n  enabled: (el, value) => {\n    el.disabled = !value;\n  },\n\n  // Disables the element when value is true (negated version of `enabled` binder).\n  disabled: (el, value) => {\n    el.disabled = !!value;\n  },\n\n  // Checks a checkbox or radio input when the value is true. Also sets the model\n  // property when the input is checked or unchecked (two-way binder).\n  checked: {\n    publishes: true,\n    priority: 2000,\n\n    bind: function(el) {\n      var self = this;\n      if (!this.callback) {\n        this.callback = function () {\n          self.publish();\n        };\n      }\n      el.addEventListener('change', this.callback);\n    },\n\n    unbind: function(el) {\n      el.removeEventListener('change', this.callback);\n    },\n\n    routine: function(el, value) {\n      if (el.type === 'radio') {\n        el.checked = getString(el.value) === getString(value);\n      } else {\n        el.checked = !!value;\n      }\n    }\n  },\n\n  // Sets the element's value. Also sets the model property when the input changes\n  // (two-way binder).\n  value: {\n    publishes: true,\n    priority: 3000,\n\n    bind: function(el) {\n      this.isRadio = el.tagName === 'INPUT' && el.type === 'radio';\n      if (!this.isRadio) {\n        this.event = el.getAttribute('event-name') || (el.tagName === 'SELECT' ? 'change' : 'input');\n\n        var self = this;\n        if (!this.callback) {\n          this.callback = function () {\n            self.publish();\n          };\n        }\n\n        el.addEventListener(this.event, this.callback);\n      }\n    },\n\n    unbind: function(el) {\n      if (!this.isRadio) {\n        el.removeEventListener(this.event, this.callback);\n      }\n    },\n\n    routine: function(el, value) {\n      if (this.isRadio) {\n        el.setAttribute('value', value);\n      } else {\n        if (el.type === 'select-multiple') {\n          if (value instanceof Array) {\n            for (let i = 0; i < el.length; i++) {\n              let option = el[i];\n              option.selected = value.indexOf(option.value) > -1;\n            }\n          }\n        } else if (getString(value) !== getString(el.value)) {\n          el.value = value != null ? value : '';\n        }\n      }\n    }\n  },\n\n  // Inserts and binds the element and it's child nodes into the DOM when true.\n  if: {\n    block: true,\n    priority: 4000,\n\n    bind: function(el) {\n      if (!this.marker) {\n        this.marker = document.createComment(' tinybind: ' + this.type + ' ' + this.keypath + ' ');\n        this.attached = false;\n\n        el.parentNode.insertBefore(this.marker, el);\n        el.parentNode.removeChild(el);\n      } else if (this.bound === false && this.nested) {\n        this.nested.bind();\n      }\n      this.bound = true;\n    },\n\n    unbind: function() {\n      if (this.nested) {\n        this.nested.unbind();\n        this.bound = false;\n      }\n    },\n\n    routine: function(el, value) {\n      value = !!value;\n      if (value !== this.attached) {\n        if (value) {\n\n          if (!this.nested) {\n            this.nested = new View(el, this.view.models, this.view.options);\n            this.nested.bind();\n          }\n\n          this.marker.parentNode.insertBefore(el, this.marker.nextSibling);\n          this.attached = true;\n        } else {\n          el.parentNode.removeChild(el);\n          this.attached = false;\n        }\n      }\n    },\n\n    update: function(models) {\n      if (this.nested) {\n        this.nested.update(models);\n      }\n    }\n  }\n};\n\nexport default binders;\n","import tinybind from './tinybind';\nimport View from './view';\nimport {OPTIONS, EXTENSIONS} from './constants';\nimport adapter from './adapter';\nimport binders from './binders';\nimport Observer from './observer';\n\n// Returns the public interface.\n\ntinybind.binders = binders;\ntinybind.adapters['.'] = adapter;\n\n// Binds some data to a template / element. Returns a tinybind.View instance.\ntinybind.bind = (el, models, options) => {\n  let viewOptions = {};\n  models = models || {};\n  options = options || {};\n\n  EXTENSIONS.forEach(extensionType => {\n    viewOptions[extensionType] = Object.create(null);\n\n    if (options[extensionType]) {\n      Object.keys(options[extensionType]).forEach(key => {\n        viewOptions[extensionType][key] = options[extensionType][key];\n      });\n    }\n\n    Object.keys(tinybind[extensionType]).forEach(key => {\n      if (!viewOptions[extensionType][key]) {\n        viewOptions[extensionType][key] = tinybind[extensionType][key];\n      }\n    });\n  });\n\n  OPTIONS.forEach(option => {\n    let value = options[option];\n    viewOptions[option] = value != null ? value : tinybind[option];\n  });\n\n  viewOptions.starBinders = Object.keys(viewOptions.binders).filter(function (key) {\n    return key.indexOf('*') > 0;\n  });\n\n  Observer.updateOptions(viewOptions);\n\n  let view = new View(el, models, viewOptions);\n  view.bind();\n  return view;\n};\n\n// Initializes a new instance of a component on the specified element and\n// returns a tinybind.View instance.\t\t\ntinybind.init = (component, el, data = {}) => {\n  if (!el) {\n    el = document.createElement('div');\n  }\n\n  component = tinybind.components[component];\n  el.innerHTML = component.template.call(tinybind, el);\n  let scope = component.initialize.call(tinybind, el, data);\n\n  let view = tinybind.bind(el, scope);\n  view.bind();\n  return view;\n};\n\ntinybind.formatters.negate = tinybind.formatters.not = function (value) {\n  return !value;\n};\n\nexport default tinybind;\n"],"names":["OPTIONS","EXTENSIONS","PRIMITIVE","KEYPATH","QUOTED_STR","parseType","string","type","value","test","slice","undefined","isNaN","str","val","JSON","parse","Array","Object","error","isJson","Number","parseTemplate","template","delimiters","tokens","length","index","lastIndex","open","close","indexOf","push","substring","lastToken","trim","adapters","interfaces","rootInterface","tinybind","this","_prefix","_fullPrefix","context","ev","binding","call","view","models","el","setAttribute","removeAttribute","options","keys","forEach","option","key","isObject","obj","Observer","keypath","callback","objectPath","getRootObject","target","realize","set","updateOptions","tokenize","root","chr","current","i","path","charAt","prototype","message","Error","substr","pop","prev","token","unreached","get","splice","sync","next","oldValue","newValue","Function","setValue","active","action","unobserve","rootProp","$parent","FORMATTER_ARGS","FORMATTER_SPLIT","Binding","binder","args","formatters","formatterObservers","model","observe","parseTarget","observer","getIterationAlias","modelName","parseFormatterArguments","formatterIndex","map","ai","_this","formattedValue","reduce","result","declaration","match","id","shift","formatter","_this2","processedArgs","read","eventHandler","fn","handler","function","routineFn","routine","publish","reduceRight","split","_this3","getValue","bind","hasOwnProperty","preloadData","unbind","_this4","fi","update","results","checked","selected","ComponentBinding","_Binding","component","components","static","observers","upstreamObservers","bindingPrefix","len","attributes","attribute","name","propertyName","camelCase","stat","locals","replace","grouped","toUpperCase","bound","componentView","innerHTML","scope","initialize","_bound","extensionType","childNodes","upstream","textBinder","node","data","DECLARATION_SPLIT","parseNode","block","nodeType","templateDelimiters","text","document","createTextNode","parentNode","insertBefore","buildBinding","removeChild","traverse","bindingComparator","a","b","aPriority","priority","trimStr","View","els","jquery","build","pipes","bindings","elements","sort","identifier","nodeName","bindInfos","starBinders","binders","k","fallbackBinder","attr","bindInfo","toLowerCase","isArray","publishes","ARRAY_METHODS","adapter","counter","defineProperty","weakmap","__rv","ref","callbacks","pointers","original","weakReference","response","apply","r","stubFunction","idx","cleanupWeakReference","desc","getOwnPropertyDescriptor","configurable","unobserveMutations","observeMutations","getString","toString","createView","anchorEl","cloneNode","marker","removeEventListener","addEventListener","iterated","createComment","collection","indexProp","getAttribute","matchIndex","nextView","nextIndex","previous","nextSibling","n","cb","elClass","className","textContent","style","display","disabled","self","isRadio","tagName","event","nested","attached","viewOptions","create","filter","init","createElement","negate","not"],"mappings":"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"}